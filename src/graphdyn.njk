{% extends "sitebase.njk" %}

{% block title %}Graphique Dynamique des 9 Piliers pour une Startup{% endblock %}

{% block site_content %}
<h2>Graphique Dynamique des 9 Piliers de la Transformation Digitale pour une Startup</h2>

<svg width="800" height="800"></svg>

<script src="https://d3js.org/d3.v6.min.js"></script>
<script>
  // Définir les données : noeuds
  const nodes = [
    { id: "Culture", group: 1 },
    { id: "Stratégie", group: 2 },
    { id: "Makers", group: 3 },
    { id: "Talents", group: 4 },
    { id: "Clients", group: 5 },
    { id: "Data & IA", group: 6 },
    { id: "Tech", group: 7 },
    { id: "Décisions", group: 8 },
    { id: "Vélocité", group: 9 },
  ];

  // Schéma de couleurs pour les bulles
  const color = d3.scaleOrdinal(d3.schemeCategory10);

  // Simuler des scores pour une startup
  const scores = {
    techMaturity: Math.floor(Math.random() * 100),      // Maturité technologique
    talentGrowth: Math.floor(Math.random() * 100),      // Croissance des talents
    clientAcquisition: Math.floor(Math.random() * 100), // Acquisition de clients
    strategicInnovation: Math.floor(Math.random() * 100),// Innovation stratégique
  };

  console.log("Scores de la startup :", scores);

  // Fonction pour générer des liaisons basées sur les scores de la startup
  function generateLinksBasedOnScores() {
    let links = [];

    // Connexions basées sur la maturité technologique
    if (scores.techMaturity > 50) {
      links.push({ source: "Tech", target: "Data & IA", value: scores.techMaturity / 100 });
      links.push({ source: "Tech", target: "Décisions", value: scores.techMaturity / 100 });
    } else {
      links.push({ source: "Culture", target: "Tech", value: 1 });
    }

    // Connexions basées sur la croissance des talents
    if (scores.talentGrowth > 50) {
      links.push({ source: "Talents", target: "Clients", value: scores.talentGrowth / 100 });
      links.push({ source: "Makers", target: "Talents", value: scores.talentGrowth / 100 });
    } else {
      links.push({ source: "Talents", target: "Culture", value: 1 });
    }

    // Connexions basées sur l'acquisition de clients
    if (scores.clientAcquisition > 50) {
      links.push({ source: "Clients", target: "Vélocité", value: scores.clientAcquisition / 100 });
      links.push({ source: "Clients", target: "Stratégie", value: scores.clientAcquisition / 100 });
    } else {
      links.push({ source: "Clients", target: "Décisions", value: 1 });
    }

    // Connexions basées sur l'innovation stratégique
    if (scores.strategicInnovation > 50) {
      links.push({ source: "Stratégie", target: "Data & IA", value: scores.strategicInnovation / 100 });
      links.push({ source: "Stratégie", target: "Tech", value: scores.strategicInnovation / 100 });
    } else {
      links.push({ source: "Stratégie", target: "Culture", value: 1 });
    }

    // Ajouter des connexions supplémentaires pour garantir que tous les nœuds sont connectés
    for (let i = 0; i < nodes.length - 1; i++) {
      if (!links.some(link => link.source === nodes[i].id && link.target === nodes[i + 1].id)) {
        links.push({ source: nodes[i].id, target: nodes[i + 1].id, value: 1 });
      }
    }

    return links;
  }

  let links = generateLinksBasedOnScores();

  const svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

  // Initialiser la simulation de force-directed graph
  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(d => 200 / d.value))  // Ajustement dynamique de la distance des liens
      .force("charge", d3.forceManyBody().strength(-300))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("x", d3.forceX(width / 2).strength(0.05))
      .force("y", d3.forceY(height / 2).strength(0.05));

  const linkGroup = svg.append("g")
      .attr("class", "links");

  const nodeGroup = svg.append("g")
      .attr("class", "nodes");

  const labelGroup = svg.append("g")
      .attr("class", "labels");

  function renderGraph() {
    const link = linkGroup.selectAll("line")
      .data(links)
      .join("line")
      .attr("class", "link")
      .style("stroke", "#999")
      .style("stroke-opacity", 0.6)
      .style("stroke-width", 2);

    const node = nodeGroup.selectAll("circle")
      .data(nodes)
      .join("circle")
      .attr("class", "node")
      .attr("r", 20)
      .style("fill", d => color(d.group))
      .style("stroke", "#fff")
      .style("stroke-width", 1.5)
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    const label = labelGroup.selectAll("text")
      .data(nodes)
      .join("text")
      .attr("dy", -25)
      .attr("dx", -20)
      .text(d => d.id)
      .style("font-size", "12px")
      .style("fill", "#000");

    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      label
        .attr("x", d => d.x)
        .attr("y", d => d.y);
    });
  }

  // Appel de la fonction pour afficher le graphe
  renderGraph();

  // Fonction pour mettre à jour les liens et redessiner le graphe
  function updateGraph() {
    links = generateLinksBasedOnScores();  // Régénérer les liaisons basées sur les scores
    simulation.force("link").links(links);  // Mettre à jour la simulation avec les nouveaux liens
    simulation.alpha(1).restart();  // Redémarrer la simulation pour qu'elle continue après chaque mise à jour
    renderGraph();  // Réafficher le graphe avec les nouvelles liaisons
  }

  // Appeler la fonction toutes les 2 secondes pour rafraîchir les scores et les connexions
  setInterval(() => {
    // Mettre à jour les scores aléatoirement
    scores.techMaturity = Math.floor(Math.random() * 100);
    scores.talentGrowth = Math.floor(Math.random() * 100);
    scores.clientAcquisition = Math.floor(Math.random() * 100);
    scores.strategicInnovation = Math.floor(Math.random() * 100);

    console.log("Nouveaux scores :", scores);
    updateGraph();
  }, 2000);

  // Fonctions de gestion du drag des noeuds
  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
</script>
{% endblock %}
